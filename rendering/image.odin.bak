package rendering

import "core:fmt"
import m "core:math"

import "shared:gl"
import "core:os"
import "core:mem"
import "core:strings"

load_bmp :: proc(filepath: string) -> (u32, Texture_Info)
{
    header: [54]byte;

    file, err := os.open(filepath);
    if err != 0
    {
        fmt.eprintf("Image %q could not be opened\n", filepath);
        return 0, Texture_Info{};
    }

    n_read, _ := os.read(file, header[:]);
    if n_read != 54 ||
        header[0] != 'B' || header[1] != 'M'
    {
        fmt.eprintf("Image %q is not a valid BMP\n", filepath);
        return 0, Texture_Info{};
    }

    data_pos   := (^u32)(&(header[0x0A]))^;
    image_size := (^u32)(&(header[0x22]))^;
    width      := (^u32)(&(header[0x12]))^;
    height     := (^u32)(&(header[0x16]))^;

    if image_size == 0 do image_size = width*height*3;
    if data_pos == 0   do data_pos = 54;

    data := make([]byte, image_size);
    n_read, _ = os.read(file, data);
    os.close(file);

    texture_id: u32;
    gl.GenTextures(1, &texture_id);
    gl.BindTexture(gl.TEXTURE_2D, texture_id);

    gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGB, i32(width), i32(height), 0, gl.BGR, gl.UNSIGNED_BYTE, &data[0]);
    delete(data);
    
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
    gl.GenerateMipmap(gl.TEXTURE_2D);

    gl.BindTexture(gl.TEXTURE_2D, 0);

    info := Texture_Info{width, height};

    return texture_id, info;
}

load_tga :: proc(filepath: string) -> (u32, Texture_Info)
{
    header: [18]byte;

    file, err := os.open(filepath);
    if err != 0
    {
        fmt.eprintf("Image %q could not be opened\n", filepath);
        return 0, Texture_Info{};
    }

    n_read, _ := os.read(file, header[:]);
    if n_read != 18
    {
        fmt.eprintf("Image %q is not a valid TGA\n", filepath);
        return 0, Texture_Info{};
    }

    id_length        := header[0x00];
    cmap_type        := header[0x01];
    image_type       := header[0x02];
    cmap_start       := (^u16)(&header[0x03])^;
    cmap_len         := (^u16)(&header[0x05])^;
    cmap_depth       := header[0x07];
    width            := (^u16)(&header[0x0C])^;
    height           := (^u16)(&header[0x0E])^;
    pixel_depth      := header[0x10];
    image_descriptor := header[0x11];

    RLE := bool(image_type & 0b1000);

    fmt.printf("======= Load TGA (%s) =======\n", filepath);
    fmt.printf("cmap_type: %hhu\n", cmap_type);
    fmt.printf("cmap_start: %hu\n", cmap_start);
    fmt.printf("cmap_len: %hu\n", cmap_len);
    fmt.printf("cmap_depth: %hhu\n", cmap_depth);

    fmt.printf("id_length: %hhu\n", id_length);
    fmt.printf("image_type: %hhu\n", image_type);
    fmt.printf("  RLE?: %s\n", RLE?"Yes":"No");
    fmt.printf("width: %hu\n", width);
    fmt.printf("height: %hu\n", height);
    fmt.printf("pixel_depth: %hhu\n", pixel_depth);
    fmt.printf("image_descriptor: %hhu\n", image_descriptor);
    fmt.printf("========================\n");

    pixel_depth_bytes := int(m.ceil(f32(pixel_depth)/8));
    cmap_depth_bytes  := int(m.ceil(f32(cmap_depth) /8));

    image_id := make([]byte, id_length);
    defer delete(image_id);
    if id_length > 0
    {
        n_read, _ = os.read(file, image_id);
        if n_read != int(id_length)
        {
            fmt.eprintf("Could not read image ID in TGA %q\n", filepath);
            return 0, Texture_Info{};
        }
    }

    cmap_data := make([]byte, int(cmap_len)*cmap_depth_bytes);
    defer delete(cmap_data);
    if cmap_type != 0
    {
        n_read, _ = os.read(file, cmap_data);
        if  n_read != len(cmap_data)
        {
            fmt.eprintf("Could not read colormap in TGa %q", filepath);
            return 0, Texture_Info{};
        }
    }

    raw_image_data := make([]byte, int(width*height)*pixel_depth_bytes);
    image_size, _ := os.read(file, raw_image_data);
    if image_size == 0
    {
        fmt.eprintf("Could not read image data in TGA %q", filepath);
        return 0, Texture_Info{};
    }

    image_data := raw_image_data[:];
    defer delete(image_data);
    
    decoded_data_size := int(width*height)*pixel_depth_bytes;
    image_data_size: int;

    if cmap_type != 0 do
        image_data_size = int(width*height)*cmap_depth_bytes;
    else do
        image_data_size = int(decoded_data_size);

    texture_id: u32;
    gl.GenTextures(1, &texture_id);
    gl.BindTexture(gl.TEXTURE_2D, texture_id);

    decoded_image_data: []byte;

    if RLE
    {
        decoded_image_data = make([]byte, decoded_data_size);
        pixel_count := 0;
        i := 0;
        decoded_index := 0;
        for pixel_count < int(width*height)
        {
            count := int(image_data[i]);
            i += 1;
            encoded := bool(count & 0x80);
            count &= 0x7F;
            if encoded
            {
                for j := 0; j < count + 1; j += 1
                {
                    mem.copy(&decoded_image_data[decoded_index], &image_data[i], int(pixel_depth_bytes));
                    decoded_index += int(pixel_depth_bytes);
                    pixel_count += 1;
                }
                i += int(pixel_depth_bytes);
            }
            else
            {
                for j in 0..count
                {
                    mem.copy(&decoded_image_data[decoded_index], &image_data[i], pixel_depth_bytes);
                    i += pixel_depth_bytes;
                    decoded_index += pixel_depth_bytes;
                    pixel_count += 1;
                }
            }
        }
        delete(image_data);
        image_data = decoded_image_data;
    }

    colormapped_image_data := make([]byte, image_data_size);
    result_depth := pixel_depth;
    if cmap_type != 0
    {
        colormapped_index := 0;
        for i in 0..<int(width*height)
        {
            mem.copy(&colormapped_image_data[colormapped_index],
                     &cmap_data[int(image_data[i*pixel_depth_bytes])*cmap_depth_bytes],
                     cmap_depth_bytes);
            colormapped_index += cmap_depth_bytes;
        }
        delete(image_data);
        image_data = colormapped_image_data;
        result_depth = cmap_depth;
    }

    switch result_depth
    {
        case 15: gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGB5,
                               i32(width), i32(height), 0, gl.BGR,
                               gl.UNSIGNED_SHORT_1_5_5_5_REV, &image_data[0]);
        case 16: gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGB5_A1,
                               i32(width), i32(height), 0, gl.BGRA,
                               gl.UNSIGNED_SHORT_1_5_5_5_REV, &image_data[0]);
        case 24: gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGB8,
                               i32(width), i32(height), 0, gl.BGR,
                               gl.UNSIGNED_BYTE, &image_data[0]);
        case 32: gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA8,
                               i32(width), i32(height), 0, gl.BGRA,
                               gl.UNSIGNED_BYTE, &image_data[0]);
        case: fmt.eprintf("Invalid color depth '%d' in TGA %q\n", result_depth, filepath);
        return 0, Texture_Info{};
    }
    
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
    gl.GenerateMipmap(gl.TEXTURE_2D);

    gl.BindTexture(gl.TEXTURE_2D, 0);

    info := Texture_Info{u32(width), u32(height)};

    return texture_id, info;
}

load_dds :: proc(filepath: string) -> (u32, Texture_Info)
{
    file, err := os.open(filepath);
    if err != 0
    {
        fmt.eprintf("Could not open image %q\n", filepath);
        return 0, Texture_Info{};
    }

    filecode: [4]byte;
    os.read(file, filecode[:]);
    if strings.string_from_ptr(&filecode[0], 4) != "DDS\x00"
    {
        fmt.eprintf("Image %q is not a valid DDS\n", filepath);
        return 0, Texture_Info{};
    }

    
    header: [124]byte;
    os.read(file, header[:]);

    height       := (^u32)(&header[0x08])^;
    width        := (^u32)(&header[0x0C])^;
    linear_size  := (^u32)(&header[0x10])^;
    mipmap_count := (^u32)(&header[0x18])^;
    four_cc      := (^u32)(&header[0x50])^;

    bufsize := mipmap_count > 1 ? linear_size * 2 : linear_size;
    buf := make([]byte, bufsize);
    defer delete(buf);
    os.read(file, buf);
    os.close(file);

    FOURCC_DXT1 :: 0x31545844;
    FOURCC_DXT3 :: 0x33545844;
    FOURCC_DXT5 :: 0x35545844;

    format: u32;
    switch four_cc
    {
    case FOURCC_DXT1: format = gl.COMPRESSED_RGBA_S3TC_DXT1_EXT;
    case FOURCC_DXT3: format = gl.COMPRESSED_RGBA_S3TC_DXT3_EXT;
    case FOURCC_DXT5: format = gl.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    case: return 0, Texture_Info{};
    }

    texture_id: u32;
    gl.GenTextures(1, &texture_id);

    gl.BindTexture(gl.TEXTURE_2D, texture_id);
    gl.PixelStorei(gl.UNPACK_ALIGNMENT, 1);

    block_size := u32(four_cc == FOURCC_DXT1 ? 8 : 16);
    offset := u32(0);

    for level in 0..<(mipmap_count)
    {
        if width == 0 && height == 0 do
            break;
        
        size := ((width+3)/4) * ((height+3)/4) * block_size;
        gl.CompressedTexImage2D(gl.TEXTURE_2D, i32(level), format,
                                i32(width), i32(height), 0, i32(size), &buf[offset]);
        offset += size;
        width  /= 2;
        height /= 2;

        if width  < 1 do width  = 1;
        if height < 1 do height = 1;
    }

    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);

    gl.BindTexture(gl.TEXTURE_2D, 0);

    info := Texture_Info{width, height};
    return texture_id, info;
}

PNG :: struct
{
    filepath      : string,
    width, height : u32,
    depth         : byte,
    color         : byte,
    palette       : [1024]byte,
    pal_len       : u32,
    has_trans     : bool,
    comp, filter  : byte,
    components    : u32,
    out_components: u32,
    pal_components: u32,
    interlace     : byte,
    data          : [dynamic]byte,
    out           : []byte,
}

_png_err :: proc(test: bool, file, message: string) -> bool
{
    if !test do
        fmt.eprintf("ERROR: %s: %s\n", file, message);

    return test;
}

load_png :: proc(filepath: string) -> (id: u32, info: Texture_Info)
{
    id = 0;
    info = Texture_Info{};

    file, ok := os.read_entire_file(filepath);
    if _png_err(!ok, filepath, "Could not open file") do return;

    trns   := [3]byte{};
    trns16 := [3]u16{};

    p := PNG{};
    p.filepath = filepath;
    first := true;
    chunk := _png_read_chunk(&file);
    for
    {
        chunk = _png_read_chunk(&file);

        switch chunk.type
        {
        case PNG_IHDR:
            if _png_err(!first, filepath, "Multiple IHDR") ||
               _png_err(chunk.size != 13, filepath, "Invalid IHDR length")
            do return;

            p.width     = u32(_read_sized(&chunk.data, u32be));
            p.height    = u32(_read_sized(&chunk.data, u32be));
            p.depth     = _read_sized(&chunk.data, byte);
            p.color     = _read_sized(&chunk.data, byte);
            p.comp      = _read_sized(&chunk.data, byte);
            p.filter    = _read_sized(&chunk.data, byte);
            p.interlace = _read_sized(&chunk.data, byte);

            if _png_err(p.color > 6, filepath, "Invalid color type") ||
               _png_err(p.color == 1 || p.color == 5, filepath, "Invalid color type") ||
               _png_err(p.color == 3 && p.depth == 16, filepath, "Invalid color type")
            do return;

            if p.color == 3 do p.pal_components = 3;

            switch p.color
            {
            case 0: p.components = 1;
            case 2: p.components = 3;
            case 4: p.components = 2;
            case 6: p.components = 4;
            }
            
            if p.pal_components == 0
            {
                p.components = (p.color & 2 != 0 ? 3 : 1) + (p.color & 4 != 0 ? 1 : 0);
            }
            else
            {
                p.components = 1; // palette index
                
                if _png_err((1<<30) / p.width / 4 < p.height, filepath, "too large")
                do return;
            }
            continue;

        case PNG_PLTE:
            if _png_err(first, filepath, "First chunk not IHDR") ||
               _png_err(chunk.size > 256*3, filepath, "Invalid PLTE")
            do return;

            p.pal_len = chunk.size / 3;
            if _png_err(p.pal_len * 3 != chunk.size, filepath, "Invalid PLTE")
            do return;
            
            for i in 0..<(p.pal_len)
            {
                p.palette[i*4+0] = _read_sized(&chunk.data, byte);
                p.palette[i*4+1] = _read_sized(&chunk.data, byte);
                p.palette[i*4+2] = _read_sized(&chunk.data, byte);
                p.palette[i*4+3] = 255;
            }

        case PNG_tRNS:
            if _png_err(first, filepath, "First chunk not IHDR") ||
               _png_err(len(p.data) > 0, filepath, "tRNS after IDAT")
            do return;

            if p.pal_components != 0
            {
                if _png_err(p.pal_len == 0, filepath, "tRNS before PLTE") ||
                   _png_err(chunk.size > p.pal_len, filepath, "Invalid tRNS")
                do return;

                p.pal_components = 4;
                for i in 0..<(chunk.size) do
                    p.palette[i*4+3] = _read_sized(&chunk.data, byte);
            }
            else
            {
                if _png_err(~p.components & 1 != 0, filepath, "tRNS with alpha channel") ||
                   _png_err(chunk.size != u32(p.components*2), filepath, "Invalid tRNS")
                do return;

                // if p.depth == 16 do
                if p.color != 3 do
                    for i in 0..<(p.components) do
                        trns16[i] = u16(_read_sized(&chunk.data, u16be));
                else do
                    for i in 0..<(p.components) do
                        trns[i] = _read_sized(&chunk.data, byte);
            }
            
        case PNG_IDAT:
            if _png_err(first, filepath, "First chunk not IHDR") do
                return;

            if p.data == nil do
                p.data = make([dynamic]byte);

            append(&p.data, ..chunk.data);
        

        case PNG_IEND:
            if _png_err(first, filepath, "First chunk not IHDR") ||
               _png_err(len(p.data) == 0, filepath, "No IDAT")
            do return;

            /* bpl := (p.width * p.depth + 7) / 8; */
            /* raw_len := bpl * p.height * p.components + p.height; */
            expanded, raw_len := _zlib_decompress(p.data);
            if _png_error(raw_len == 0, filepath, "Error decompressing PNG") do
                return;
            
            delete(p.data);

            p.out_components = p.components;
            if p.has_trans do
                p.out_components += 1;
            
            p.data = _create_png(p, expanded, raw_len);
            delete(expanded);

            if p.has_trans
            {
                if p.depth == 16 do
                    _png_compute_transparency16(p, trans16);
                else do
                    _png_compute_transparency8(p, trans);
            }
            
            _png_expand_palette(p);

        case:
            if _png_err(first, filepath, "first not IHDR")
            do return;
        }
        
        delete(chunk.data);
    }

    
    return 0, Texture_Info{};
}

_png_read_chunk :: proc(file: ^[]u8) -> PNG_Chunk
{
    chunk := PNG_Chunk{};

    chunk.size = u32(_read_sized(file, u32be));
    chunk.type = u32(_read_sized(file, u32be));
    
    chunk.data = make([]byte, size);
    copy(chunk.data, file);
    file = file[len(chunk.data):];

    chunk.crc = u32(_read_sized(file, u32be));

    return chunk;
}

_create_png :: proc(p: ^PNG, data: []byte, raw_len: int) -> []byte
{
    image: []byte;
    if p.interlaced do
        image = _png_deinterlace(p, data, raw_len);
    else do
        image = _png_defilter(p, data, raw_len);

    return image;
}

PNG_IHDR :: 0x49484452;
PNG_PLTE :: 0x504c5445;
PNG_IDAT :: 0x49444154;
PNG_IEND :: 0x49454e44;

PNG_cHRM :: 0x6348524d;
PNG_gAMA :: 0x67414d41;
PNG_sBIT :: 0x73424954;
PNG_sRGB :: 0x73524742;
PNG_bKGD :: 0x624b4744;
PNG_hIST :: 0x68495354;
PNG_tRNS :: 0x74524e53;
PNG_pHYs :: 0x70485973;
PNG_sPLT :: 0x73504c54;
PNG_tIME :: 0x74494d45;
PNG_iTXt :: 0x69545874;
PNG_tEXt :: 0x74455874;
PNG_zTXt :: 0x7a545874;

PNG_Chunk :: struct
{
    size:  u32,
    type:  u32,
    data:  []byte,
    crc32: u32,
}

_read_sized :: proc (file: ^[]byte, $T: typeid) -> T
{
    if len(file^) < size_of(T)
    {
        fmt.eprintf("Expected %T, got EOF\n", typeid_of(T));
        return T(0);
    }
    p := a + b - c;
    pa := abs(p-a);
    pb := abs(p-b);
    pc := abs(p-c);

    if pa <= pb && pa <= pc do return a;
    if pb <= pc do return b;
    return c;
}

PNG_Filter :: enum
{
    None,
    Sub,
    Up,
    Avg,
    Paeth,
}

_png_deinterlace :: proc(p: ^PNG, data: []byte, size: int) -> []byte
{
    bytes := p.depth == 16 ? 2 : 1;
    out_bytes := p.out_components * bytes;
    deinterlaced := make([]byte, p.width*p.height*out_bytes);

    origin := [7][2]int{
        {0, 0},
        {4, 0},
        {0, 4},
        {2, 0},
        {0, 2},
        {1, 0},
        {0, 1},
    };

    spacing := [7][2]int{
        {8, 8},
        {8, 8},
        {4, 8},
        {4, 4},
        {2, 4},
        {2, 2},
        {1, 2},
    };
    
    for pass in 0..<(7)
    {
        // Number of pixels per-axis in this pass
        count_x := (p.width  - origin[pass].x + spacing[pass].x-1) / spacing[pass].x;
        count_y := (p.height - origin[pass].y + spacing[pass].y-1) / spacing[pass].y;

        if count_x != 0 && count_y != 0
        {
            sub_image_len := ((((p.components * count_x * p.depth) + 7) >> 3) + 1) * count_y;
            sub_image := _png_defilter(p, data, count_x, count_y);
            
            for y in 0..<(count_y)
            {
                for x in 0..<(count_x)
                {
                    out_y := y * spacing[pass].y + origin[pass].y;
                    out_x := x * spacing[pass].x + origin[pass].x;
                    mem.copy(&deinterlaced[out_y*p.width*out_bytes + out_x*out_bytes:],
                             &data[(y*count_x + x)*out_bytes], out_bytes);
                }
            }
            
            data = data[sub_image_len:];
        }
    }

    return deinterlaced;
}

_png_defilter :: proc(p: ^PNG, data: []byte, x, y: int) -> []byte
{
    x := x;
    y := y;
    
    bytes := p.depth == 16 ? 2 : 1;
    bit_depth := p.depth;
    pixel_depth := (bit_depth+7) >> 3;
    
    img_width_bytes := ((p.components * x * bit_depth) + 7) >> 3;
    img_len := (img_width_bytes + 1) * y;
    
    output_bytes := p.out_components * bytes;
    filter_bytes := p.components * bytes;
    
    prev_row: []byte;
    row := data;
    stride := x * u32(pixel_depth);
    
    image := make([]byte, x*y*u32(output_bytes));
    working := image;
    for i in 0..<(y)
    {
        filter := PNG_Filter(row[0]);
        row = row[1:];
        off := i*stride;

        if _png_err(filter > 4, p.filepath, "Invalid filter") do
            return;

        /* if bit_depth < 8 */
        /* { */
        /*     assert(img_width_bytes <= p.width); */
        /*     off += p.width * p.out_components - img_width_bytes; */
        /*     filter_bytes = 1; */
        /*     x = img_width_bytes; */
        /* } */
        working = image[off:];

        switch filter
        {
        case .None:
            for j in 0..<(x) do
                for k in 0..<(filter_bytes)
                {
                    ri := j*filter_bytes+k;
                    oi := j*output_bytes+k;
                    
                    working[oi] = row[ri];
                }    
            
        case .Sub:
            for j in 0..<(x)
            {
                for k in 0..<(filter_bytes)
                {
                    ri := j*filter_bytes+k;
                    oi := j*output_bytes+k;
                    
                    a := byte(0);
                    if j != 0 do
                        a = working[oi - output_bytes];
                    working[oi] = row[ri] + a;
                }
            }

        case .Up:
            for j in 0..<(x)
            {
                for k in 0..<(filter_bytes)
                {
                    ri := j*filter_bytes+k;
                    oi := j*output_bytes+k;
                    
                    b := byte(0);
                    if y != 0 do
                        b = prev_row[ri];
                    working[oi] = row[ri] + b;
                }
            }

        case .Avg:
            for j in 0..<(x)
            {
                for k in 0..<(filter_bytes)
                {
                    ri := j*filter_bytes+k;
                    oi := j*output_bytes+k;
                    
                    a := byte(0);
                    b := byte(0);
                    if j != 0 do
                        a = working[oi - output_bytes];
                    if y != 0 do
                        b = prev_row[ri];

                    working[oi] = row[ri] + (a+b)/2;
                }
            }

        case .Paeth:
            for j in 0..<(x)
            {
                for k in 0..<(filter_bytes)
               {
                    ri := j*filter_bytes+k;
                    oi := j*output_bytes+k;
                    
                    a := byte(0);
                    b := byte(0);
                    c := byte(0);

                    if j != 0
                    {
                        a = working[oi - output_bytes];
                        if y != 0 do
                            c = prev_row[ri - output_bytes];
                    }

                    if y != 0 do
                        b = prev_row[ri];
                    
                    paeth := _png_paeth_predict(i32(a), i32(b), i32(c));
                    working[oi] = row[ri] + byte(paeth);
                }
            }
        }
        
        for j in 0..<(x)
        {
            working[j*output_bytes+filter_bytes] = 255;
            if p.depth == 16 do
                working[j*output_bytes+filter_bytes+1] = 255;
        }
        
        prev_row = working;
        row = row[stride:];
    }

    // @TODO(Tyler): Support for 1/2/4 bit color depth

    // @NOTE(Tyler): Swap endianness to platform native
    if p.depth == 16
    {
        working = image;
        working_be := mem.slice_data_cast([]u16be, working);
        working_16 := mem.slice_data_cast([]u16,   working);

        for _, i in working_16 do
            working_16[i] = u16(working_be[i]);
    }

    return image;
}
    
_png_compute_transparency8 :: proc(p: ^PNG, trans: [3]u8)
{
    assert(p.out_components == 2 || p.out_components == 4);

    if p.out_components == 2
    {
        data := mem.slice_data_cast([][2]u8, p.data);
        for pixel in data do
            pixel[1] = pixel[0] == trans[0] ? 0 : 255;
    }
    else
    {
        data := mem.slice_data_cast([][4]u8, p.data);
        for pixel in data do
            if pixel[0] == trans[0]
            && pixel[1] == trans[1]
            && pixel[2] == trans[2] do
                pixel[3] = 0;
    }
}

_png_compute_transparency16 :: proc(p: ^PNG, trans: [3]u16)
{
    assert(p.out_components == 2 || p.out_components == 4);

    if p.out_components == 2
    {
        data := mem.slice_data_cast([][2]u16, p.data);
        for pixel in data do
            pixel[1] = pixel[0] == trans[0] ? 0 : 255;
    }
    else
    {
        data := mem.slice_data_cast([][4]u16, p.data);
        for pixel in data do
            if pixel[0] == trans[0]
            && pixel[1] == trans[1]
            && pixel[2] == trans[2] do
                pixel[3] = 0;
    }
}

_png_expand_palette :: proc(p: ^PNG)
{
    expanded := make([]byte, p.width * p.height * p.pal_components);

    for i in p.width*p.height do
        mem.copy(&expanded[i*p.pal_components:], &p.palette[p.data[i]*4:], p.pal_components);

    delete(p.data);
    p.data = expanded;
}
